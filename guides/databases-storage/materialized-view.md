---
title: "Materialized View"
description: "Process scheduling is how an operating system decides which process runs next. This guide covers key algorithms like Round Robin, Priority, and Shortest Job First to manage CPU time efficiently."
excerpt: "الـ Materialized View مش مجرد Query بتتنفذ كل مرة زي الـ Views العادية. ولكن هي بتنفذ الـ Query مرة واحدة بس وتخزن النتيجة فعليًا في جدول جديد جوا الـ Database."
tags: ["query-optimization" , "performance", "database", "materialized-view"]
updatedAt: "2024-09-08"
featured: false
image: "https://assets.eqraatech.com/guides/materialized-view.png"
author: "mahyoussef"
---

<img src="https://assets.eqraatech.com/guides/materialized-view.png" alt="Materialized View" ondragstart="return false;" oncontextmenu="return false;" style="display: block; margin: 2rem auto; border-radius: 1rem; box-shadow: 0 4px 24px 0 rgba(0,0,0,0.08);" />

في عالم قواعد البيانات، دايمًا المشكلة بتكون في كيفية تحسين الـ `Performance` بتاعة الـ `Queries` اللي شغالين عليها وفيه أكتر من طريقة لتحسين الأداء وتسهيل الوصول للبيانات وكنا اتكلمنا عن بعضهم قبل كده.

واحدة من الطرق دي هي **Views**. فالـ `View` هو عبارة عن `Query` بتجيب البيانات من جدول أو أكتر وتقدمهالك كأنها جدول مستقل تماماً. يعني مثلاً، لو عندك جدول فيه الكتب وجدول تاني فيه المؤلفين، ممكن تعمل `View` يعرض لك البيانات المهمة من الجدولين دول مع بعض ويكون فيه بس الـ `Columns` اللي مجتاجها.

الـ `View` العادية ممتازة لما يكون عندك بيانات بتتغير بشكل مستمر، لأنها دايمًا بتجيب البيانات الأحدث. لكن المشكلة بتظهر امتة ؟ المشكلة بتظهر لو عندنا كمية كبيرة وضخمة من البيانات أو الـ `Query` معقدة شويتين فبالتالي هيبقى فيه بطء شديد في الأداء ككل. وهنا بيجي دور الـ **Materialized Views** كحل سحري يقدر يوفرلنا الأداء المطلوب.

---

## Materialized View

الـ Materialized View مش مجرد `Query` بتتنفذ كل مرة زي الـ `Views` العادية. ولكن هي بتنفذ الـ `Query` مرة واحدة بس وتخزن النتيجة فعليًا في جدول جديد جوا الـ Database.

فالميزة الكبيرة هنا إننا لما نطلب البيانات دي تاني، مش هنحتاج الـ Query تتنفذ من الأول، وبالتالي السرعة بتبقى أفضل بكتير جدًا.

فلو بنتعامل مع قواعد بيانات كبيرة أو `Queries` معقدة شوية، وكان عندنا `Query` على سبيل المثال محتاجة بيانات من أكتر من جدول وبتنفذ عمليات حسابية معقدة، في الحالة دي كل مرة بنطلب فيها البيانات دي السيرفر هيستهلك وقت ومجهود كبير. ولكن مع الـ Materialized View، احنا بنخزن النتيجة مرة واحدة وبعد كده أي Query بتيجي للبيانات بيكون أسرع بكتير لاننا بس بنقرأ الجدول اكنه جدول جديد موجود في الـ Database.

طب الكلام ده جميل جدًا لحد كده ، ولكن احنا ناسيين نقطة مهمة .. ايه اللي هيحصل في الجدول ده لو الجداول القديمة فيها قيم اتغيرت أو بيانات اتحذفت أو بيانات جديدة انضافت ؟

---

على عكس الـ `View` الطبيعي اللي بيتغير لما البيانات الأصلية تتغير لانه بيعيد تنفيذ الـ `Query` من أول وجديد، الـ `Materialized View` مش هيتحدث تلقائيًا لوحده. وعشان كده، لازم نعمل تحديث للـ `Materialized View` بشكل دوري عشان نضمن إن البيانات اللي فيه دايمًا حديثة.

**فيه طرق مختلفة للتحديث، أشهرها:**

1. **الـ Complete Refresh**: وفي الطريقة دي كل اللي بنعمله اننا بنمسح البيانات المخزنة القديمة ونرجع بكل بساطة ننفذ الـ Query من أول وجديد عشان نجيب البيانات الحديثة كلها. فدي بتبقى مفيدة جدًا لو التغييرات على البيانات الأصلية بتبقى كبيرة.
2. **الـ Incremental Refresh**: وفي الطريقة دي كل اللي بنعمله اننا بنحدث بس البيانات اللي اتغيرت من آخر مرة عملنا فيها تحديث للـ Materialized View. يعني لو اتضافت أو اتعدلت بيانات جديدة، التحديث ده بس اللي هيضيفها أو يعدلها بس من غير ما يمسح أي بيانات القديمة.